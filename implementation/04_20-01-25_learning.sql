-- NUMERIC 

CREATE TABLE table_serial(
	p_id SERIAL,
	p_name VARCHAR(100)
);

INSERT INTO table_serial (p_name)
VALUES 
('pen')
;

SELECT *
FROM table_serial
;

INSERT INTO table_serial (p_name)
VALUES 
('paper')
;


-- DECIMAL
-- numeric(precision, scale) 
-- real - after decimal point precision upto 6 digits
-- double - after decimal point precision upto 15 digits

CREATE TABLE table_num (
	col_numeric numeric(20,5),
	col_real real,
	col_double double precision
);

SELECT *
FROM table_num
;

INSERT INTO table_num (col_numeric, col_real, col_double) VALUES
(.9, .9, .9),
(3.13579, 3.13579, 3.13579),
(4.1357987654, 4.1357987654, 4.1357987654)
;
 -- Date/Time 
 -- Date - stores date only
 -- Time - stores time only
 -- Timestamp - stores date and time
 -- Timestamptz - stores date, time and timestamp
 -- Interval - stores values


-- DATE 

CREATE TABLE table_date(
	id SERIAL PRIMARY KEY,
	emp_name VARCHAR(100) NOT NULL,
	hire_date DATE NOT NULL,
	add_date DATE DEFAULT CURRENT_DATE
);

INSERT INTO table_date (emp_name, hire_date) VALUES
('Abc', '2024-12-16'),
('Xyz', '2025-01-01')
;

SELECT *
FROM table_date;

SELECT NOW();

SELECT CURRENT_DATE;


-- TIME
-- column_name TIME(precision) - precision upto 6 digits
-- Common Formats :
/* 
HH:MM
HH:MM:SS
HHMMSS

MM:SS.pppppp
HH:MM:SS.pppppp
HHMMSS.pppppp
*/


CREATE TABLE table_time(
	id SERIAL PRIMARY KEY,
	c_name VARCHAR(100) NOT NULL,
	start_time TIME NOT NULL,
	end_time TIME NOT NULL
);

INSERT INTO table_time (c_name, start_time, end_time) VALUES
('MATHS','08:00:00', '09:00:00'),
('CHE', '09:01:00', '10:00:00')
;

SELECT * FROM table_time;

SELECT CURRENT_TIME, CURRENT_TIME(3);

SELECT LOCALTIME, LOCALTIME(2);

SELECT CURRENT_TIME, LOCALTIME;


-- Arithmetic Operations

SELECT TIME '12:00:00' - TIME '04:00:00';

-- Using INTERVAL
-- INTERVAL 'n type'
-- n = number
-- type = second, minute, hour, day, month, year

SELECT CURRENT_TIME, CURRENT_TIME + INTERVAL '1 hour' AS res_time;

SELECT CURRENT_TIME, CURRENT_TIME + INTERVAL '-1 hour' AS res_time;

-- TIMESTAMP, TIMESTAMPTZ

CREATE TABLE table_tz (
	ts TIMESTAMP,
	ts_tz TIMESTAMPTZ
);

INSERT INTO table_tz (ts, ts_tz) VALUES
('2025-01-20 10:10:10-07', '2025-01-20 10:10:10-07')
;

SELECT * FROM table_tz;

SHOW TIMEZONE;

-- SELECT * FROM pg_timezone_names;

SELECT CURRENT_TIMESTAMP;

SELECT TIMEOFDAY();

SELECT timezone('America/New_York', '2025-01-01 00:00:00');


-- UUID = Universal Unique Identifier
-- 128 bit quantity generated by an algotithm that make it unique

-- To create a UUID in Postgre, we need a third party UUID algo e.g. uuis-ossp

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

SELECT uuid_generate_v1(); -- v1() - use MAC address + Current Timestamp + Random

SELECT uuid_generate_v4(); -- v4() - Pure Random


CREATE TABLE table_uuid(
	p_id UUID DEFAULT uuid_generate_v1(),
	p_name VARCHAR(100) NOT NULL
);

INSERT INTO table_uuid (p_name) VALUES
('p1'),
('p2'),
('p3')
;

ALTER TABLE table_uuid
ALTER COLUMN p_id
SET DEFAULT uuid_generate_v4()
;

INSERT INTO table_uuid (p_name) VALUES
('p4'),
('p5'),
('p6')
;

SELECT * FROM table_uuid;

-- Array 
-- varibale datatype []
-- e.g. phones TEXT []

CREATE TABLE table_arr(
	id SERIAL,
	name VARCHAR(100),
	phones TEXT[]
);

SELECT * FROM table_arr;

INSERT INTO table_arr (name,phones) VALUES
('name1', ARRAY ['9912873456', '5643981256']),
('name2', ARRAY ['8877665544', '1122334455'])
;

SELECT * FROM table_arr;

SELECT phones[1]
FROM table_arr
;

-- hstore
-- stores data into key-value pair
-- hstore module implements the hstore data type
-- keys and values are text strings only

CREATE EXTENSION IF NOT EXISTS hstore;

CREATE TABLE table_hstore(
	id SERIAL PRIMARY KEY,
	title VARCHAR(100) NOT NULL,
	book_info hstore
);

INSERT INTO table_hstore (title, book_info) VALUES
(
	'TITLE 1', 
	'
		"publisher" => "XYZ",
		"paper_cost" => "10.00",
		"e_cost" => "5.50"
	'
);

INSERT INTO table_hstore (title, book_info) VALUES
(
	'TITLE 2', 
	'
		"publisher" => "ABC",
		"paper_cost" => "12.00",
		"e_cost" => "9.99",
		"publish_year" => "2024"
	'
);

SELECT * FROM table_hstore;

-- -> operator - specific hstore value

SELECT 
	book_info -> 'publisher' AS publisher,
	book_info -> 'e_cost' AS "Electronic Cost"
FROM table_hstore
;

-- JSON

CREATE TABLE table_json(
	id SERIAL PRIMARY KEY,
	docs JSON
);

INSERT INTO table_json (docs) VALUES
('[1,2,3,4,5,6]'),
('[3,4,5,6,7,8]'),
('{"key1":"value1"}')
;

SELECT * FROM table_json;

SELECT docs FROM table_json;

SELECT * 
FROM table_json
WHERE docs @> '2'; -- ERROR


ALTER TABLE table_json
ALTER COLUMN docs TYPE JSONB;

SELECT * 
FROM table_json
WHERE docs @> '2';

CREATE INDEX ON table_json USING GIN(docs jsonb_path_ops);

-- Network Address Datatypes
	-- cidr - 7 or 19 bytes - IPv4 and IPv6 networks
	-- inet - 7 or 19 bytes - IPv4 and IPv6 hosts and networks
	-- macaddr - 6 bytes - MAC addresses
	-- macaddr8 - 8 bytes - MAC addresses(EUI-64 format)

	-- when sorting inet or cidr types : IPv4 addresses will always sort before IPv6 addresses

CREATE TABLE table_netaddr (
	id SERIAL PRIMARY KEY,
	ip INET
);

INSERT INTO table_netaddr (ip) VALUES 
('4.35.221.243'),
('4.152.207.126'),
('4.15.11.254'),
('3.201.202.203'),
('5.35.112.211'),
('14.21.72.34')
;

SELECT * FROM table_netaddr;

-- set_masklen function : 	set netmask langth for inet value

SELECT 
	ip, 
	set_masklen(ip,24) AS inet_24
FROM table_netaddr;

SELECT 
	ip,
	set_masklen(ip,24) AS inet_24,
	set_masklen(ip::cidr, 24) AS cidr_24
FROM table_netaddr;


SELECT 
	ip,
	set_masklen(ip,24) AS inet_24,
	set_masklen(ip::cidr, 24) AS cidr_24,
	set_masklen(ip::cidr, 27) AS cidr_27,
	set_masklen(ip::cidr, 28) AS cidr_28
FROM table_netaddr;




	

